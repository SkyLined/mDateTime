<!DOCTYPE html>
<html>
  <head>
    <script src="cDate.js"></script>
    <script src="cDateDuration.js"></script>
    <script>
      "use strict";
      function fMustBeEqual(xValue1, xValue2, sErrorMessage) {
        if (!(
          xValue1 !== null
          && xValue2 !== null
          && (xValue1.constructor === cDate || xValue1.constructor === cDateDuration)
          && (xValue2.constructor === cDate || xValue2.constructor === cDateDuration)
          && xValue1.toString() === xValue2.toString()
        )) {
          throw new Error(sErrorMessage);
        };
      };
      function fDatePlustDurationMustEqual(sStartDate, sDuration, sEndDate) {
        const oStartDate = cDate.foFromString(sStartDate),
              oDuration = cDateDuration.foFromString(sDuration),
              oEndDate = cDate.foFromString(sEndDate),
              oCalculatedEndDate = oStartDate.foGetEndDateForDuration(oDuration),
              oCalculatedDuration = oStartDate.foGetDurationForEndDate(oEndDate),
              oNormalizedDuration = oDuration.foNormalizedForDate(oStartDate);
        fMustBeEqual(
          oEndDate,
          oCalculatedEndDate,
          sStartDate + " " + sDuration + " == " + oCalculatedEndDate.toString() + " (NOT " + sEndDate.toString() + ")"
        );
        fMustBeEqual(
          oCalculatedDuration,
          oNormalizedDuration,
          sStartDate + " -> " + sEndDate + " == " + oCalculatedDuration.toString() + " (NOT " + oNormalizedDuration.toString() + ")"
        );
      };
      function fNormalizedDurationForDateMustEqual(sDuration, sDate, sExpectedNormalizedDuration) {
        const oNormalizedDuration = cDateDuration.foFromString(sDuration).foNormalizedForDate(cDate.foFromString(sDate));
        fMustBeEqual(
          oNormalizedDuration,
          cDateDuration.foFromString(sExpectedNormalizedDuration),
          sDuration + " normalized for " + sDate + " == " + oNormalizedDuration.toString() + " (NOT " + sExpectedNormalizedDuration + ")"
        );
      };
      fDatePlustDurationMustEqual("2000-01-01", "+1y", "2001-01-01");
      fDatePlustDurationMustEqual("2000-01-01", "+12m", "2001-01-01");
      fDatePlustDurationMustEqual("2000-01-01", "+366d", "2001-01-01"); // 2000 is a leap year.
      fDatePlustDurationMustEqual("2001-01-01", "+1y", "2002-01-01");
      fDatePlustDurationMustEqual("2001-01-01", "+12m", "2002-01-01");
      fDatePlustDurationMustEqual("2001-01-01", "+365d", "2002-01-01"); // 2001 is not a leap year.
      
      fDatePlustDurationMustEqual("2000-02-01", "+28d", "2000-02-29"); // 2000 is a leap year.
      fDatePlustDurationMustEqual("2000-02-01", "+29d", "2000-03-01"); // 2000 is a leap year.
      fDatePlustDurationMustEqual("2001-02-01", "+28d", "2001-03-01"); // 2001 is not a leap year.
      fDatePlustDurationMustEqual("2000-01-01", "+1y+1m+28d", "2001-03-01"); // 2001 is not a leap year; days are applied last.
      
      fDatePlustDurationMustEqual("2000-01-01", "+1m", "2000-02-01");
      fDatePlustDurationMustEqual("2000-01-01", "+31d", "2000-02-01");
      
      fDatePlustDurationMustEqual("2000-01-01", "+1d", "2000-01-02");
      
      fDatePlustDurationMustEqual("2000-01-01", "+1y1m1d", "2001-02-02");
      
      fNormalizedDurationForDateMustEqual("1y1m1d", "2000-01-01", "1y1m1d");
      fNormalizedDurationForDateMustEqual("+1y-1m+31d", "2000-01-01", "1y");
      fNormalizedDurationForDateMustEqual("+2 years, -12 months, -366 day", "2000-01-01", "0d");
      
      const oTestDate = new cDate(2000, 2, 28),
            oNoNewTestDate = cDate(2000, 2, 28),
            oFromStringTestDate = cDate.foFromString("2000-02-28"),
            oFromJSONTestDate = cDate.foFromJSON("2000-02-28"),
            oClonedTestDate = oTestDate.foClone();
      fMustBeEqual(oTestDate, oNoNewTestDate, "cDate(2000, 2, 28) should not result in " + oNoNewTestDate.toString());
      fMustBeEqual(oTestDate, oFromStringTestDate, "cDate.foFromString(\"2000-02-28\") should not result in " + oFromStringTestDate.toString());
      fMustBeEqual(oTestDate, oFromJSONTestDate, "cDate.foFromJSON(\"2000-02-28\") should not result in " + oFromJSONTestDate.toString());
      fMustBeEqual(oTestDate, oClonedTestDate, oTestDate + " should not be cloned as " + oClonedTestDate.toString());
      
      oTestDate.uDay = 29;
      let bHasThrownException = false;
      try {
        oTestDate.uYear = 2001;
      } catch (e) {
        bHasThrownException = true;
      };
      if (!bHasThrownException) throw new Error(oTestDate.toString() + " should not be possible.");
      bHasThrownException = false;
      oTestDate.uDay = 28;
      oTestDate.uYear = 2001;
      try {
        oTestDate.uDay = 29;
      } catch (e) {
        bHasThrownException = true;
      };
      if (!bHasThrownException) throw new Error(oTestDate.toString() + " should not be possible.");
      bHasThrownException = false;
      oTestDate.uMonth = 1;
      oTestDate.uDay = 29;
      try {
        oTestDate.uMonth = 2;
      } catch (e) {
        bHasThrownException = true;
      };
      if (!bHasThrownException) throw new Error(oTestDate.toString() + " should not be possible.");
      
      const oDate1 = new cDate(2000, 1, 1),
            oDate2 = new cDate(2000, 1, 2),
            oDate3 = new cDate(2000, 2, 1),
            oDate4 = new cDate(2001, 1, 1);
      if (!oDate1.fbIsEqualTo(oDate1)) throw new Error(oDate1.toString() + " should be equal to itself.");
      if (!oDate1.fbIsBefore(oDate2)) throw new Error(oDate1.toString() + " should be before " + oDate2.toString() + ".");
      if (!oDate1.fbIsBefore(oDate3)) throw new Error(oDate1.toString() + " should be before " + oDate3.toString() + ".");
      if (!oDate1.fbIsBefore(oDate4)) throw new Error(oDate1.toString() + " should be before " + oDate4.toString() + ".");
      
      if (!oDate2.fbIsAfter(oDate1)) throw new Error(oDate2.toString() + " should be after " + oDate1.toString() + ".");
      if (!oDate2.fbIsEqualTo(oDate2)) throw new Error(oDate2.toString() + " should be equal to itself.");
      if (!oDate2.fbIsBefore(oDate3)) throw new Error(oDate2.toString() + " should be before " + oDate3.toString() + ".");
      if (!oDate2.fbIsBefore(oDate4)) throw new Error(oDate2.toString() + " should be before " + oDate4.toString() + ".");
      
      if (!oDate3.fbIsAfter(oDate1)) throw new Error(oDate3.toString() + " should be after " + oDate1.toString() + ".");
      if (!oDate3.fbIsAfter(oDate2)) throw new Error(oDate3.toString() + " should be after " + oDate2.toString() + ".");
      if (!oDate3.fbIsEqualTo(oDate3)) throw new Error(oDate3.toString() + " should be equal to itself.");
      if (!oDate3.fbIsBefore(oDate4)) throw new Error(oDate3.toString() + " should be before " + oDate4.toString() + ".");
      
      if (!oDate4.fbIsAfter(oDate1)) throw new Error(oDate4.toString() + " should be after " + oDate1.toString() + ".");
      if (!oDate4.fbIsAfter(oDate2)) throw new Error(oDate4.toString() + " should be after " + oDate2.toString() + ".");
      if (!oDate4.fbIsAfter(oDate3)) throw new Error(oDate4.toString() + " should be after " + oDate3.toString() + ".");
      if (!oDate4.fbIsEqualTo(oDate4)) throw new Error(oDate4.toString() + " should be equal to itself.");
      
      document.write("All tests successful.");
    </script>
  </head>
</html>